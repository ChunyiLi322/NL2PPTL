/* Generated By:JavaCC: Do not edit this line. FormulaParser.java */
package formulaParser;

import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import btree.TreeNode;
import mainPro.ConfigPath;
import mainPro.Write2File;
import stanfordnlp.Demo;
import java.util.ArrayList;
import wordnet.GetWordSynsetsTest;
import pptlsat.PPTLSATRunTime;
import java.util.HashMap;
import DrawTree.DrawStandardizedTree;
import javax.swing.JOptionPane;

public class FormulaParser implements FormulaParserConstants {


  public static TreeNode root=new TreeNode();
  public static TreeNode root2=new TreeNode();  //根节点
  public static String return_String = "";
  public static String sub_String = "";
  public static int nodecount=0;
                   /**
			这里添加添加五元组--------------------------------------
			*/
  public static ArrayList principal_class = new ArrayList();
  public static ArrayList active_trigger_class = new ArrayList();
  public static ArrayList attribute_class = new ArrayList();
   public static ArrayList action_scope_class = new ArrayList();
                   /**
			-------------------------------------------------------
			*/
  public static String formula = "";
  public static String formula2 = "";
  public static HashMap<String,String> hashmap;
  public static HashMap<String,String> hashmap2;
  public static int principal_class_count = 0;
  public static FormulaParser parser = null;

  public static HashMap<String,String> main(String args []) throws ParseException,IOException
  {
    Demo stanforddemo =new Demo();
    String sentence= null;
    InputStream is = null;
    hashmap = null;
    hashmap2 =null;
                   /**
			这里添加添加五元组-------------------------------------------------
			*/
    String principal_class_Write_In_String = "";
    String active_trigger_class_Write_In_String ="";
    String attribute_class_Write_In_String ="";
    String action_scope_class_Write_In_String ="";
                   /**
			----------------------------------------------------------
			*/
    String sargs=args[0];
                   /**
			下面两句，用来打印生成的二叉树和可视化二叉树
			*/
    is= stanforddemo.toStanfordmark(sargs);
    if(parser==null)
    {
      parser = new FormulaParser(is);
     }else
     {
       ReInit(is);
       }

      System.out.println("Reading from standard input...");
      System.out.print("Enter an expression like \u005c"when..if.....\u005c" :");
      try
      {
        switch (FormulaParser.sentence())
        {
          case 0 :
          System.out.println(return_String);
          System.out.println("OK.");
          return_String = "";
          sub_String = "";
                  hashmap=new HashMap<String,String>();
                  hashmap2=new HashMap<String,String>();
                   /**
			下面两句，用来打印生成的二叉树和可视化二叉树
			*/
          root2=root;
                  DrawStandardizedTree draw_tree = new DrawStandardizedTree(root);
                  draw_tree.console_print_tree(root,1);
                  formula=printtree(root);
                  formula2=printtree2(root2);
          System.out.println("formula:  "+formula);
          System.out.println("formula2:  "+formula2);
          System.out.println("\u4e3b\u4f53\u7c7b:  ");

            /**
			这里添加添加五元组----------------------------------------------------------------------
			*/
//          write_to_file("主语类",principal_class,principal_class_Write_In_String,"store_principal_class","principal");
//          write_to_file("主动触发类",active_trigger_class,active_trigger_class_Write_In_String,"store_active_trigger_class","active_trigger");
//          write_to_file("作用域类",action_scope_class,action_scope_class_Write_In_String,"action_scope_class","action_scope");
//          write_to_file("属性类",attribute_class,attribute_class_Write_In_String,"attribute_class","attribute");

                  /**
			---------------------------------------------------------------------------------------------------
			*/
                  System.out.println("\u7ec6\u7c92\u5ea6hashmap2:  "+hashmap2);
          hashmap.put("PPTLformula",formula);
          hashmap.put("PPTLformula_Fine_grained",formula2);
          break;
          case 1 :
          System.out.println("Goodbye.");
          break;
          default :
        }
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        hashmap = null;
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
      }
//    }
//	return formula; 
        return hashmap;


  }






/**
**************************************************************************
****此方法为构建返回字符串
    输入为   将句子1，节点单词标签1，节点单词值
	输出为   句子2  ， 句子2 =句子+ 加空格+节点单词值
*/


  public static String appendString(String clause,String biaoji,String value)
  {
    return clause+" "+value;
  }

  /**
**************************************************************************
***  可视化逻辑树
**** lichunyi 12-14
*/



  /**
**************************************************************************
加入  whenever  if  的情况
补充  next 的情况
*/




  public static String printtree(TreeNode root)
  {
    //后序遍历
    String formula="";
    String leftformula="";
    String rightformula="";
    String fine_grained_principal_class="";
    String fine_grained_active_trigger_class="";
    String formula2="";
    if(root.svalue != null){
      if(root.left!=null){
         leftformula=printtree(root.left);
         }
      if(root.right!=null){
                 rightformula=printtree(root.right);
                 }
          if(root.type==0) //打印子句 转换成命题
                {
                  //char x=(char)((int)'P'+root.ivalue);
                  char x_P=(char)((int)'P');
          String x=x_P+""+root.ivalue;
                  String temporal="";
                  hashmap.put(x+"",root.svalue);
                  switch(root.mark)
                  {
                    case 1: temporal="[]"+x;
                        break;
                    case 2: temporal="<>"+x;
                        break;
                    case 3: temporal="(fin("+x+"))";
                        break;
                    case 4: temporal="()"+x;
                        break;
                    case -1: temporal=""+x;
                        break;
                    }
                        formula=temporal;
                        System.out.println(temporal+":  "+root.svalue);
                }else
                {
                  System.out.println("subordinator / conjunction "+root.svalue);
                  if(root.svalue.equals("when")||root.svalue.equals("When"))
                  {
                    formula="( "+leftformula+" ) -> ()( "+rightformula+" )";

                  }
                  if(root.svalue.equals("whenever")||root.svalue.equals("Whenever"))
                  {
                    formula="( "+leftformula+" ) -> <>( "+rightformula+" )";

                  }
                  if(root.svalue.equals("after")||root.svalue.equals("After"))
                  {
                    formula="( "+rightformula+" ) -> <>( "+leftformula+" )";

                  }
                  if(root.svalue.equals("until")||root.svalue.equals("Until"))
                  {
                    formula="( "+rightformula+" ) until ( "+leftformula+" )";

                  }
                  if(root.svalue.equals("before")||root.svalue.equals("before"))
                  {
                    formula="( "+leftformula+" ) -> <>( "+rightformula+" )";

                  }
                   if(root.svalue.equals("while")||root.svalue.equals("while"))
                  {
                    formula="( "+leftformula+" ) -> ()( "+rightformula+" )";

                  }
                  else if(root.svalue.equals("if")||root.svalue.equals("If"))
                  {
                    formula="( "+leftformula+" ) -> ()( "+rightformula+" )";

                  }
                  else if(root.svalue.equals("and"))
                  {
                    formula="( "+leftformula+" ) && ( "+rightformula+" )";

                  }
                   else if(root.svalue.equals("or"))
                  {
                    formula="( "+leftformula+" ) || ( "+rightformula+" )";

                  }
                  else if(root.svalue.equals("then"))
                  {
                    formula="( "+leftformula+" ) ; ( "+rightformula+" )";

                  }
                  else if(root.svalue.equals("next"))
                  {
                    formula="( "+leftformula+" ) ; ( "+rightformula+" )";

                  }
                   else if(root.svalue.equals("Start"))
                  {
                    if(rightformula != null && ! rightformula.equals("")) {
                      formula="( " + leftformula + " , " + rightformula + " )";

                    }else {
                      formula="( " + leftformula + " )";

                    }
                  }
                  else if(root.svalue.equals("End"))
                  {
                    if(rightformula != null && ! rightformula.equals("")) {
                      formula="( " + leftformula + " , " + rightformula + " )";

                    }else {
                      formula="( " + leftformula + " )";

                    }
                  }
                  else if(root.svalue.equals("prj"))
                  {
                    formula="( " + leftformula + " )" +" prj " + rightformula;

                  }
                  else if(root.svalue.equals("mainClause"))
                  {
                    formula=leftformula +" && " + rightformula;

                  }
                  else if(root.svalue.equals("subordinateClause"))
                  {
                    if(leftformula != null && ! leftformula.equals("")&&rightformula != null && ! rightformula.equals("")) {
                      formula= leftformula + " && " + rightformula  ;

                    }else {
                      formula= leftformula +rightformula;

                    }
                  }
                  else if(root.svalue.equals("Which")||root.svalue.equals("which")||root.svalue.equals("That")||root.svalue.equals("that"))
                  {
                    formula=leftformula + rightformula;

                  }
                  else if(root.svalue.equals("clauseObject")||root.svalue.equals("clauseSubject"))
                  {
                    if(leftformula != null && ! leftformula.equals("")&&rightformula != null && ! rightformula.equals("")) {
                      formula= leftformula + "&&" + rightformula;

                    }else {
                      formula=leftformula+rightformula;

                    }
                  }
                }

        }
        System.out.println("\u8f93\u51faformula\u516c\u5f0f\u4e3a\uff1a"+formula);
        System.out.println("\u8f93\u51faformula2\u516c\u5f0f\u4e3a\uff1a"+formula2);
        return formula;
  }






  /**
**************************************************************************
细粒度打印
*/



  public static String printtree2(TreeNode root)
  {
    //后序遍历
    String formula="";
    String leftformula="";
    String rightformula="";
                   /**
			这里添加添加五元组--------------------------------------
			*/
    String fine_grained_principal_class="";
    String fine_grained_active_trigger_class="";
    String fine_grained_attribute_class="";
    String fine_grained_action_scope_class="";
                   /**
			这里添加添加五元组--------------------------------------
			*/
    String formula2="";
    if(root.svalue != null){
      if(root.left!=null){
         leftformula=printtree2(root.left);
         }
      if(root.right!=null){
                 rightformula=printtree2(root.right);
                 }
          if(root.type==0) //打印子句 转换成命题
                {
                  //char x=(char)((int)'P'+root.ivalue);
                  char x_P=(char)((int)'P');
          String x=x_P+""+root.ivalue;
                  String temporal="";
                  hashmap.put(x+"",root.svalue);
                                   /**
			这里添加添加五元组--------------------------------------
			*/
                  fine_grained_principal_class= principal_class.get(principal_class_count).toString();
                  fine_grained_active_trigger_class= active_trigger_class.get(principal_class_count).toString();
                  fine_grained_attribute_class= attribute_class.get(principal_class_count).toString();
          fine_grained_action_scope_class= action_scope_class.get(principal_class_count).toString();

                  principal_class_count++;



                  hashmap2.put(fine_grained_principal_class+"___"+fine_grained_active_trigger_class
                  +"___"+fine_grained_attribute_class+"___"+fine_grained_action_scope_class,root.svalue);
                  String y =fine_grained_principal_class+"___"+fine_grained_active_trigger_class
                  +"___"+fine_grained_attribute_class+"___"+fine_grained_action_scope_class;
                                   /**
			这里添加添加五元组--------------------------------------
			*/
                  switch(root.mark)
                  {
                    case 1: temporal="[]"+x;
                        break;
                    case 2: temporal="<>"+x;
                        break;
                    case 3: temporal="(fin("+x+"))";
                        break;
                    case 4: temporal="()"+x;
                        break;
                    case -1: temporal=""+x;
                        break;
                    }
                        formula=temporal;
                  switch(root.mark)
                  {
                    case 1: temporal="[]"+y;
                        break;
                    case 2: temporal="<>"+y;
                        break;
                    case 3: temporal="(fin("+y+"))";
                        break;
                    case 4: temporal="()"+y;
                        break;
                    case -1: temporal=""+y;
                        break;
                    }
                        formula2=temporal;
                        System.out.println(temporal+":  "+root.svalue);
                }else
                {
                  System.out.println("subordinator / conjunction "+root.svalue);
                  if(root.svalue.equals("when")||root.svalue.equals("When"))
                  {
                    formula="( "+leftformula+" ) -> ()( "+rightformula+" )";
                    formula2="( "+leftformula+" ) -> ()( "+rightformula+" )";
                  }
                  if(root.svalue.equals("whenever")||root.svalue.equals("Whenever"))
                  {
                    formula="( "+leftformula+" ) -> <>( "+rightformula+" )";
                    formula2="( "+leftformula+" ) -> <>( "+rightformula+" )";
                  }
                  if(root.svalue.equals("after")||root.svalue.equals("After"))
                  {
                    formula="( "+rightformula+" ) -> <>( "+leftformula+" )";
                    formula2="( "+rightformula+" ) -> <>( "+leftformula+" )";
                  }
                  if(root.svalue.equals("until")||root.svalue.equals("Until"))
                  {
                    formula="( "+rightformula+" ) until ( "+leftformula+" )";
                    formula2="( "+rightformula+" ) until ( "+leftformula+" )";
                  }
                  if(root.svalue.equals("before")||root.svalue.equals("before"))
                  {
                    formula="( "+leftformula+" ) -> <>( "+rightformula+" )";
                    formula2="( "+leftformula+" ) -> <>( "+rightformula+" )";
                  }
                   if(root.svalue.equals("while")||root.svalue.equals("while"))
                  {
                    formula="( "+leftformula+" ) -> ()( "+rightformula+" )";
                    formula2="( "+leftformula+" ) -> ()( "+rightformula+" )";
                  }
                  else if(root.svalue.equals("if")||root.svalue.equals("If"))
                  {
                    formula="( "+leftformula+" ) -> ()( "+rightformula+" )";
                    formula2="( "+leftformula+" ) -> ()( "+rightformula+" )";
                  }
                  else if(root.svalue.equals("and"))
                  {
                    formula="( "+leftformula+" ) && ( "+rightformula+" )";
                    formula2="( "+leftformula+" ) && ( "+rightformula+" )";
                  }
                   else if(root.svalue.equals("or"))
                  {
                    formula="( "+leftformula+" ) || ( "+rightformula+" )";
                    formula2="( "+leftformula+" ) || ( "+rightformula+" )";
                  }
                  else if(root.svalue.equals("then"))
                  {
                    formula="( "+leftformula+" ) ; ( "+rightformula+" )";
                    formula2="( "+leftformula+" ) ; ( "+rightformula+" )";
                  }
                  else if(root.svalue.equals("next"))
                  {
                    formula="( "+leftformula+" ) ; ( "+rightformula+" )";
                    formula2="( "+leftformula+" ) ; ( "+rightformula+" )";
                  }
                   else if(root.svalue.equals("Start"))
                  {
                    if(rightformula != null && ! rightformula.equals("")) {
                      formula="( " + leftformula + " , " + rightformula + " )";
                      formula2="( " + leftformula + " , " + rightformula + " )";
                    }else {
                      formula="( " + leftformula + " )";
                      formula2="( " + leftformula + " )";
                    }
                  }
                  else if(root.svalue.equals("End"))
                  {
                    if(rightformula != null && ! rightformula.equals("")) {
                      formula="( " + leftformula + " , " + rightformula + " )";
                      formula2="( " + leftformula + " , " + rightformula + " )";
                    }else {
                      formula="( " + leftformula + " )";
                      formula2="( " + leftformula + " )";
                    }
                  }
                  else if(root.svalue.equals("prj"))
                  {
                    formula="( " + leftformula + " )" +" prj " + rightformula;
                    formula2="( " + leftformula + " )" +" prj " + rightformula;
                  }
                  else if(root.svalue.equals("mainClause"))
                  {
                    formula=leftformula +" && " + rightformula;
                    formula2=leftformula +" && " + rightformula;
                  }
                  else if(root.svalue.equals("subordinateClause"))
                  {
                    if(leftformula != null && ! leftformula.equals("")&&rightformula != null && ! rightformula.equals("")) {
                      formula= leftformula + " && " + rightformula  ;
                      formula2= leftformula + " && " + rightformula  ;
                    }else {
                      formula= leftformula +rightformula;
                      formula2= leftformula +rightformula;
                    }
                  }
                  else if(root.svalue.equals("Which")||root.svalue.equals("which")||root.svalue.equals("That")||root.svalue.equals("that"))
                  {
                    formula=leftformula + rightformula;
                    formula2=leftformula + rightformula;
                  }
                  else if(root.svalue.equals("clauseObject")||root.svalue.equals("clauseSubject"))
                  {
                    if(leftformula != null && ! leftformula.equals("")&&rightformula != null && ! rightformula.equals("")) {
                      formula= leftformula + "&&" + rightformula;
                      formula2= leftformula + "&&" + rightformula;
                    }else {
                      formula=leftformula+rightformula;
                      formula2=leftformula+rightformula;
                    }
                  }
                }

        }
        System.out.println("\u8f93\u51faformula\u516c\u5f0f\u4e3a\uff1a"+formula);
        System.out.println("\u8f93\u51faformula2\u516c\u5f0f\u4e3a\uff1a"+formula2);
        return formula2;
  }

  /**
**************************************************************************
同义词
*/


  public static int WordSynsets(String word) throws IOException{
    System.out.println("word1  "+word);
    if(word.equals("eventually")) {//对eventually 单独处理
      return 2;
    }


    ArrayList<String> synWords=new ArrayList<String>();
    ArrayList<String> synWords1=new ArrayList<String>();
    ArrayList<String> synWords2=new ArrayList<String>();
    ArrayList<String> synWords3=new ArrayList<String>();
    GetWordSynsetsTest getWordSynsetsTest=new GetWordSynsetsTest();
    try {
      synWords=getWordSynsetsTest.GetWordSynsets(word);
    }catch(Exception e)
     {
        System.out.println("catch(IOException e)  ");
        return -1;
      // e.printStackTrace();
       }
    System.out.println("catch(IOException e) 1 ");

    synWords1=getWordSynsetsTest.GetWordSynsets("always");

    synWords2=getWordSynsetsTest.GetWordSynsets("sometimes");

    synWords3=getWordSynsetsTest.GetWordSynsets("finally");

//    for(int i=0;i<synWords.size();i++)
//    {
//      System.out.println("syn  "+synWords.get(i));
//    }

        synWords1.retainAll(synWords);
        synWords2.retainAll(synWords);
        synWords3.retainAll(synWords);
        System.out.println("catch(IOException e) 2 ");
        System.out.println("word  "+word);
        if(synWords1.size() >0)
        {
          return 1;
        }
        else if(synWords2.size() >0)
        {
          return 2;
        }
        else if(synWords3.size() >0)
        {
          return 3;
        }
    return -1;
  }

/**
*******************************************************************************************
*这里是temporal中的返回string与预置的几个词做匹配，
*mark=1 对应的是[]逻辑符号
*mark=2 对应的是< >逻辑符号
*mark=3 对应的是fin()逻辑符号
*mark=4 对应的是()逻辑符号
*mark=-1 没有对应逻辑符号
*
*更改default内容，如果副词，介词等不表示时序内容，我们应将它还原回原句子中，不应该直接删除
*  即增加 sub_String=appendString(sub_String,"< temporal >",word);
*
*/




public static int prepWords(String word){
     int  mark=-1;
   switch (word)
   {
     case "all the time":
     case "at all times": mark= 1; break;
     case "at times":
     case "at a time":
     case "from time to time":
     case "now and then":
     case "at whiles":
     case "in the future":
     case "on occasion":mark= 2;break;
     case "in the end": mark= 3;break;
     case "in the next state":
     case "in the next time":
     case "on the next state": mark= 4;break;
     default: sub_String=appendString(sub_String,"< temporal >",word); break;
   }
   return mark;
  }

/**
**************************************************************************
****此方法为将五元组信息输入到文本中
*/

public static  void write_to_file(String write_chinese_name, ArrayList active_trigger_class, String active_trigger_class_Write_In_String,String store_path, String write_English_name)
{
  System.out.println(write_chinese_name+":  ");
  for(int i = 0 ; i<active_trigger_class.size();i++){
         System.out.println(active_trigger_class.get(i));
         active_trigger_class_Write_In_String =active_trigger_class_Write_In_String +"\u005ct"+ active_trigger_class.get(i);
         Write2File.WriteIn(active_trigger_class_Write_In_String,ConfigPath.change_path(store_path),write_English_name);
        }

}

  /**
**************************************************************************
大句子分成完整小句子
*/
  static final public int sentence() throws ParseException {
  TreeNode subclauses=new TreeNode();
   TreeNode clauses=new TreeNode();
   TreeNode subclause1=new TreeNode();
   TreeNode subclauseS=new TreeNode();
   TreeNode subclauseE=new TreeNode();
   String conjunctionsvalue="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VB:
      markprjS();
      subclauseS = subclauses();
      jj_consume_token(44);
      markprjE();
      subclauseE = subclauses();
      jj_consume_token(45);
             TreeNode prjConjunction=new TreeNode();
         prjConjunction.type=1;
         prjConjunction.svalue="prj";
         prjConjunction.left=subclauseS;
         prjConjunction.right=subclauseE;
      root=prjConjunction;
      System.out.println("root.svalue="+root.svalue);

    {if (true) return 0;}
      break;
    case WRB:
    case WDT:
    case NN:
    case NNS:
    case NNP:
    case CD:
    case VBG:
    case VBN:
    case IN:
    case JJ:
    case JJS:
    case JJR:
    case RB:
    case DT:
    case PRP:
    case HYPH:
    case 44:
    case 45:
    case 46:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WRB:
      case WDT:
      case NN:
      case NNS:
      case NNP:
      case CD:
      case VBG:
      case VBN:
      case IN:
      case JJ:
      case JJS:
      case JJR:
      case RB:
      case DT:
      case PRP:
      case HYPH:
      case 44:
      case 45:
        subclauses = subclauses();
        label_1:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 44:
            ;
            break;
          default:
            jj_la1[0] = jj_gen;
            break label_1;
          }
          jj_consume_token(44);
          conjunctionsvalue = conjunction();
                                                System.out.println("\u53e5\u5b50\u662f\u5426\u6709\u8fde\u8bcdconjunctionsvalue="+conjunctionsvalue);
          subclause1 = subclauses();
                             if(!conjunctionsvalue.equals(""))  //存在 conjunction 另一subclauses  构建conjunction 并让subclauses 节点指向该节点
                             {
                               System.out.println("conjunctionsvalue \u4e0d\u7a7a="+conjunctionsvalue);
                               TreeNode conjunction=new TreeNode();
                               conjunction.type=1;
                               conjunction.svalue=conjunctionsvalue;
                               conjunction.left=subclauses;
                               conjunction.right=subclause1;
                               subclauses=conjunction;
                             }else {
                               System.out.println("conjunctionsvalue \u7a7a="+conjunctionsvalue);
                               TreeNode conjunction=new TreeNode();
                               conjunction.type=1;
                               conjunction.svalue="";
                               conjunction.left=subclauses;
                               conjunction.right=subclause1;
                               subclauses=conjunction;
                            }
        }
        jj_consume_token(45);
      root=subclauses;
      System.out.println("root.svalue="+root.svalue);

    {if (true) return 0;}
        break;
      case 46:
        jj_consume_token(46);
    {if (true) return 1;}
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*完整的句子中依据标点符号分成的几个简单句。
*
*
*/
  /**
**************************************************************************
小句子根据逗号继续分
*/
  static final public TreeNode subclauses() throws ParseException {
   TreeNode subclause=new TreeNode();
   TreeNode clauses=new TreeNode();
   subclause.type=1;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WRB:
      case WDT:
      case IN:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      subclause = subclause();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 44:
        jj_consume_token(44);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
                                         System.out.println("subclause=-----------");
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NN:
    case NNS:
    case NNP:
    case CD:
    case VBG:
    case VBN:
    case JJ:
    case JJS:
    case JJR:
    case RB:
    case DT:
    case PRP:
    case HYPH:
      clauses = clauses();
             System.out.println("clauses=-----------");
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
          System.out.println("subclauses STOP-----------");
          if(subclause.svalue!=null)
          {
             subclause.right=clauses;
                 {if (true) return subclause;}
           }else
           {
             {if (true) return clauses;}
           }
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*以下是监控语句的实现内容
*
*
*/
  static final public TreeNode subclausesPrj() throws ParseException {
   TreeNode prjConjunction=new TreeNode();
   TreeNode subclauseS=new TreeNode();
   TreeNode subclauseE=new TreeNode();
    subclauseS = subclausesS();
    subclauseE = subclausesE();
         prjConjunction.type=1;
         prjConjunction.svalue="prj";
         prjConjunction.left=subclauseS;
         prjConjunction.right=subclauseE;
         {if (true) return prjConjunction;}
    throw new Error("Missing return statement in function");
  }

  static final public TreeNode subclausesE() throws ParseException {
   TreeNode subclause=new TreeNode();
   TreeNode clauses=new TreeNode();
   subclause.type=1;
    subclause = subclauseE();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 44:
      jj_consume_token(44);
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
                                         System.out.println("subclauseE=-----------");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NN:
    case NNS:
    case NNP:
    case CD:
    case VBG:
    case VBN:
    case JJ:
    case JJS:
    case JJR:
    case RB:
    case DT:
    case PRP:
    case HYPH:
      clauses = clausesPrj();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 44:
        jj_consume_token(44);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
                                        System.out.println("clausesE=-----------");
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    jj_consume_token(46);
           System.out.println("subclausesE STOP-----------");
          if(subclause.svalue!=null)
          {
             subclause.right=clauses;
                {if (true) return subclause;}
           }
           else
           {
             {if (true) return clauses;}
           }
    throw new Error("Missing return statement in function");
  }

  static final public TreeNode subclausesS() throws ParseException {
   TreeNode subclause=new TreeNode();
   TreeNode clauses=new TreeNode();
   subclause.type=1;
    subclause = subclauseS();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 44:
      jj_consume_token(44);
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
                                         System.out.println("subclauseS=-----------");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NN:
    case NNS:
    case NNP:
    case CD:
    case VBG:
    case VBN:
    case JJ:
    case JJS:
    case JJR:
    case RB:
    case DT:
    case PRP:
    case HYPH:
      clauses = clausesPrj();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 44:
        jj_consume_token(44);
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
                                        System.out.println("clausesS=-----------");
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
          if(subclause.svalue!=null)
          {
             subclause.right=clauses;
                {if (true) return subclause;}
           }
           else
           {
             {if (true) return clauses;}
           }
    throw new Error("Missing return statement in function");
  }

  static final public TreeNode subclauseE() throws ParseException {
   TreeNode subordinator=new TreeNode();
   subordinator.type=1;
    //   (markprj())?  //prj标记
      subordinator.svalue = markprjE();
    subordinator.left = clause();
    System.out.println("subordinatorE.svalue="+subordinator.svalue);

    {if (true) return subordinator;}
    throw new Error("Missing return statement in function");
  }

  static final public TreeNode subclauseS() throws ParseException {
   TreeNode subordinator=new TreeNode();
   subordinator.type=1;
    //   (markprj())?  //prj标记
      subordinator.svalue = markprjS();
    subordinator.left = clause();
    System.out.println("subordinatorS.svalue="+subordinator.svalue);

    {if (true) return subordinator;}
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*/



/**
*******************************************************************************************
*被完整句子分出来的简单句
*
*
*/
  static final public TreeNode subclause() throws ParseException {
   TreeNode subordinator=new TreeNode();
   subordinator.type=1;
    //   (markprj())?  //prj标记
      subordinator.svalue = subordinator();
    subordinator.left = clauses();
    System.out.println("subordinator.svalue="+subordinator.svalue);

    {if (true) return subordinator;}
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*12-16补充if and  and  and识别，开始不支持if 并列多个句子 ，主句  的情况
*句子的并列成分识别
*
*/
  static final public TreeNode clauses() throws ParseException {
   TreeNode conjunction=new TreeNode();
   conjunction.type=1;
   TreeNode clause=new TreeNode();
  Token node;
     System.out.println("clauses\u6811\u8282\u70b9\u7684value\u8bc6\u522b START");
    clause = clause();
     System.out.println("clauses  subclausesPrj STOP");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CC:
    case IN:
    case RB:
      conjunction.svalue = conjunction();
      conjunction.right = clause();
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CC:
    case IN:
    case RB:
      conjunction.svalue = conjunction();
      conjunction.right = clauses();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
     System.out.println("clauses STOP");
     if(conjunction.svalue!=null)
     {
       conjunction.left=clause;
       System.out.println("conjunction.svalue="+conjunction.svalue);
       {if (true) return conjunction;}
     }
     else
     {
         {if (true) return clause;}  //如果有并列成分 返回并列成分 没有 返回最前子句
     }
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*监控
*
*/
  static final public TreeNode clausesPrj() throws ParseException {
   TreeNode conjunction=new TreeNode();
   conjunction.type=1;
   TreeNode clause=new TreeNode();
  Token node;
    clause = clause();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CC:
    case IN:
    case RB:
      conjunction.svalue = conjunction();
      conjunction.right = clause();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
     System.out.println("clausesPrj stop");
     if(conjunction.svalue!=null)
     {
       conjunction.left=clause;
       System.out.println("conjunction.svalue="+conjunction.svalue);
       {if (true) return conjunction;}
     }
     else
     {
         {if (true) return clause;}  //如果有并列成分 返回并列成分 没有 返回最前子句
     }
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*递归遍历识别完整简单句子的开始
*加入to do不定式
*
*/

/**
*******************************************************************************************
*小完整句子成分分解
*
*/
  static final public TreeNode clause() throws ParseException {
  Token node;
  String name_string;
  String scope_string = "";
  TreeNode clause=new TreeNode();//根节点
  TreeNode clauseSubject=new TreeNode();//主语的定语从句
  TreeNode clauseObject=new TreeNode();//宾语的定语从句
  TreeNode mainClause=new TreeNode();//主句节点
  TreeNode subordinateClause=new TreeNode();//从句节点
  clause.type=0;
  clauseSubject.type=-1;
  clauseObject.type=-1;
  mainClause.type=-1;
  mainClause.svalue="mainClause";
  subordinateClause.type=-1;
  subordinateClause.svalue="subordinateClause";
  String mainClause_sub_String = "";
  sub_String = "";
  String temporalmark;
  temporalmark="";
  boolean predicatesmark=false;
    subject();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WRB:
    case WDT:
    case IN:
      clauseSubject = subclause();
                                          System.out.println("\u4e3b\u8bed\u6709\u5b9a\u8bed\u4ece\u53e5\u7684\u60c5\u51b5");
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    predicatesmark = predicates();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TOPRE:
      scope_string = to_prep();
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NN:
    case NNS:
    case NNP:
    case CD:
    case VBD:
    case VBG:
    case VBN:
    case JJ:
    case JJS:
    case JJR:
    case RB:
    case DT:
    case PRP:
    case HYPH:
      object();
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
    case TOPRE:
      action_scope();
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
      mainClause_sub_String=sub_String;
     {
            /**
				同步principal_class和active_trigger_class*******************************************************
		*/
                int balance_size[] = new int[4];
                balance_size[0] = principal_class.size();
                balance_size[1] = active_trigger_class.size();
                    balance_size[2] = attribute_class.size();
                    balance_size[3] = action_scope_class.size();
                    if(attribute_class.size()>0 & scope_string!="")
                    {
                    System.out.println("\u73b0\u5728\u5c5e\u6027\u4e3a"+attribute_class.get(attribute_class.size()-1));
            attribute_class.set(attribute_class.size()-1, scope_string + attribute_class.get(attribute_class.size()-1));
            System.out.println("\u6539\u53d8\u4ee5\u540e\u5c5e\u6027\u4e3a"+attribute_class.get(attribute_class.size()-1));
            }
            if(attribute_class.size()==0 & scope_string!="")
            {
             attribute_class.add(scope_string);
            }
            int balance_size_max = 0;
                        for(int i=0; i<4; i++)
                        {
                          if(balance_size[i] > balance_size_max)
                          {
              balance_size_max = balance_size[i];
                          }
                        }
                        if(balance_size_max > balance_size[0])
                        {
                 principal_class.add("no_principal");
                        }
                        if(balance_size_max > balance_size[1])
                        {
                 active_trigger_class.add("no_active_trigger");
                        }
                        if(balance_size_max > balance_size[2])
                        {
                 attribute_class.add("no_attribute");
                        }
                        if(balance_size_max > balance_size[3])
                        {
                 action_scope_class.add("no_action_scope");
                        }
     }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WRB:
      case WDT:
      case IN:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_3;
      }
      clauseObject = subclause();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
    case RB:
    case PDT:
    case RP:
    case TOPRE:
      temporalmark = temporal();
         System.out.println("temporalmark="+temporalmark);
         System.out.println("clause.mark="+clause.mark);
     try {
       if(!temporalmark.equals("")&&!temporalmark.contains(" "))
       {
          System.out.println("WordSynsets="+ WordSynsets(temporalmark));
          clause.mark=WordSynsets(temporalmark);
          System.out.println("WordSynsets clause.mark="+ clause.mark);
       }else if(clause.mark==-1)
       {
            clause.mark=prepWords(temporalmark);
             System.out.println("prepWords mark="+ prepWords(temporalmark));
       }
       else
       {
         clause.mark=-1;
       }
     }
     catch(IOException e)
     {

       e.printStackTrace();
       }
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
     clause.ivalue=nodecount++;
         clause.svalue=mainClause_sub_String;

         if(mainClause_sub_String.equals("")||mainClause_sub_String==null) {
           clause.svalue=sub_String;
           }
     System.out.println(sub_String);//输出子句
     System.out.println("mainClause_sub_String="+mainClause_sub_String);
     System.out.println("clause.svalue="+clause.svalue);
     if(clause.mark==-1) //当句子没有副词 和介词短语 表达时序语义时 用时态表示
     {
       if(predicatesmark)  clause.mark=2; //句子是将来时态 标记
       }
     if(clauseSubject.svalue!=null||clauseObject.svalue!=null) {
          clauseSubject.svalue="clauseSubject";
          clauseObject.svalue="clauseObject";
          subordinateClause.left=clauseObject;
          subordinateClause.right=clauseSubject;
          mainClause.left=clause;
          mainClause.right=subordinateClause;
          {if (true) return mainClause;}
       }
     {if (true) return clause;}  //返回节点

    throw new Error("Missing return statement in function");
  }

  static final public String markprjS() throws ParseException {
  Token node;
    node = jj_consume_token(VB);
    jj_consume_token(START);
    jj_consume_token(NN);
    jj_consume_token(MONITORING);
    jj_consume_token(IN);
    jj_consume_token(WITH);
                                                             System.out.println("< markprj >  <START>"+node.image );  return_String=appendString(return_String,"< markprj >",node.image); sub_String= appendString(sub_String,"< markprj >",node.image); {if (true) return node.image;}
    throw new Error("Missing return statement in function");
  }

  static final public String markprjE() throws ParseException {
  Token node;
    node = jj_consume_token(NN);
    jj_consume_token(END);
    jj_consume_token(NN);
    jj_consume_token(MONITORING);
    jj_consume_token(IN);
    jj_consume_token(WITH);
                                                           System.out.println("< markprj >  <END>"+node.image);  return_String=appendString(return_String,"< markprj >",node.image); sub_String= appendString(sub_String,"< markprj >",node.image);{if (true) return node.image;}
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*subordinator()用来识别主语从句的连接词
*
*
*连接词分为两种 WRB WDT
*

*添加 IF引导的从句
*/
  static final public String subordinator() throws ParseException {
  Token node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WRB:
      jj_consume_token(WRB);
      node = jj_consume_token(IDENTIFIER);
                          System.out.println("< subordinator >  <WRB>"+node.image);  return_String=appendString(return_String,"< subordinator >",node.image); sub_String= appendString(sub_String,"< subordinator >",node.image); {if (true) return node.image;}
      break;
    case WDT:
      jj_consume_token(WDT);
      node = jj_consume_token(IDENTIFIER);
                          System.out.println("< subordinator >  <WDT>"+node.image);  return_String=appendString(return_String,"< subordinator >",node.image); sub_String= appendString(sub_String,"< subordinator >",node.image); {if (true) return node.image;}
      break;
    case IN:
      jj_consume_token(IN);
      node = jj_consume_token(IDENTIFIER);
                          System.out.println("< subordinator >  <IN>"+node.image);  return_String=appendString(return_String,"< subordinator >",node.image); sub_String= appendString(sub_String,"< subordinator >",node.image); {if (true) return node.image;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*to do 不定式
*
*
*
*/
  static final public String to_prep() throws ParseException {
  Token node;
  String action_scope_class_string = "";
   System.out.println("to_prep()\u904d\u5386\u5f00\u59cb------------------------");
    jj_consume_token(TOPRE);
    node = jj_consume_token(IDENTIFIER);
    System.out.println("< to_prep >  < TO >"+node.image);
  return_String=appendString(return_String,"< subordinator >",node.image);
  sub_String= appendString(sub_String,"< subordinator >",node.image);
  action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RB:
    case IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RB:
        jj_consume_token(RB);
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      node = jj_consume_token(IDENTIFIER);
    System.out.println("< to_prep >  < RB >"+node.image);
  return_String=appendString(return_String,"< subordinator >",node.image);
  sub_String= appendString(sub_String,"< subordinator >",node.image);
  action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VB:
    case IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VB:
        jj_consume_token(VB);
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      node = jj_consume_token(IDENTIFIER);
    System.out.println("< to_prep >  < VB >"+node.image);
  return_String=appendString(return_String,"< subordinator >",node.image);
  sub_String= appendString(sub_String,"< subordinator >",node.image);
  action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NN:
    case IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NN:
        jj_consume_token(NN);
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      node = jj_consume_token(IDENTIFIER);
                           System.out.println("< to_prep >  < NN >"+node.image);
   return_String=appendString(return_String,"< subordinator >",node.image);
   sub_String= appendString(sub_String,"< subordinator >",node.image);
   action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
  System.out.println("to_prep()\u904d\u5386\u7ed3\u675f------------------------");
  {if (true) return action_scope_class_string;}
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*/
  static final public String conjunction() throws ParseException {
  Token node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CC:
      jj_consume_token(CC);
      node = jj_consume_token(IDENTIFIER);
                        System.out.println("\u8fde\u63a5\u8bcd\u7684conjunction()\u65b9\u6cd5< conjunction > CC"+node.image);
  return_String=appendString(return_String,"< conjunction >",node.image);
  sub_String=appendString(sub_String,"< conjunction >",node.image);
  {if (true) return node.image;}
      break;
    case RB:
      jj_consume_token(RB);
      //then
        node = jj_consume_token(IDENTIFIER);
                        System.out.println("\u8fde\u63a5\u8bcd\u7684conjunction()\u65b9\u6cd5< conjunction > RB"+node.image);
  return_String=appendString(return_String,"< conjunction > < RB >",node.image);
  sub_String=appendString(sub_String,"< conjunction >",node.image);
  {if (true) return node.image;}
      break;
    case IN:
      jj_consume_token(IN);
      //after
        node = jj_consume_token(IDENTIFIER);
   if(node.image.equals("after")|node.image.equals("before")|node.image.equals("until"))
  {
    System.out.println("\u8fde\u63a5\u8bcd\u7684conjunction()\u65b9\u6cd5< conjunction > "+node.image);
    return_String=appendString(return_String,"< conjunction > after",node.image);
    sub_String=appendString(sub_String,"< conjunction >",node.image);
    {if (true) return node.image;}}
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
加入 < RP >
*/
  static final public void modifier() throws ParseException {
   Token node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RB:
      jj_consume_token(RB);
      break;
    case RP:
      jj_consume_token(RP);
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    node = jj_consume_token(IDENTIFIER);
                          System.out.println("\u526f\u8bcd\u7684modifier()\u65b9\u6cd5< modifier >< RB > "+node.image);
  return_String= appendString(return_String,"< modifier >",node.image);
  sub_String=appendString(sub_String,"< modifier >",node.image);
  }

/**
*******************************************************************************************
*时序语义的识别,更改形容词  < JJ > 变更为 < JJ >|< JJS >
* 识别顺序为：
*(1)< RB>|< RB >< CC >
*(2)< IN > (< DT >)?((< JJ >|< JJS >))?(< NN >|< NNS >)*
*(3)< PDT >< DT >< NN > (2)< IN > (< DT >)?((< JJ >|< JJS >|< CD >))?(< NN >|< NNS >)*
*加入< CD > < VBG > 加入< RB >副词修饰形容词
加入< HYPH >-< VBN >
加入名次并列和形容西并列情况
*/
  static final public String temporal() throws ParseException {
  Token node;
  String temporal="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RB:
     System.out.println("\u5f00\u59cb\u8bc6\u522b\u65f6\u5e8f\u77ed\u8bed---------------------------------");
      jj_consume_token(RB);
      //识别副词
              node = jj_consume_token(IDENTIFIER);
                               System.out.println("\u65f6\u5e8f\u8bc6\u522b\u4e3a\u526f\u8bcdtemporal()\uff1a< temporal > RB "+node.image); return_String= appendString(return_String,"< temporal >",node.image); temporal=node.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CC:
        jj_consume_token(CC);
        node = jj_consume_token(IDENTIFIER);
                                    System.out.println("\u65f6\u5e8f\u8bc6\u522b\u4e3a\u526f\u8bcd\u52a0CC\u526f\u8bcd+RB\u526f\u8bcdtemporal()\uff1a< temporal > RB CC "+node.image); return_String= appendString(return_String,"< temporal >",node.image); temporal+=" "+node.image;
        jj_consume_token(RB);
        //识别副词 CC 副词
                node = jj_consume_token(IDENTIFIER);
                               System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > RB "+node.image); return_String= appendString(return_String,"< temporal >",node.image); temporal+=" "+node.image;
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
                System.out.println("temporal = "+temporal);
                {if (true) return temporal;}
      break;
    case IN:
    case PDT:
    case RP:
    case TOPRE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
        jj_consume_token(IN);
        node = jj_consume_token(IDENTIFIER);
                                 System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > IN "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal=node.image;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DT:
          jj_consume_token(DT);
          node = jj_consume_token(IDENTIFIER);
                                     System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > DT "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
          break;
        default:
          jj_la1[31] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RB:
          jj_consume_token(RB);
          node = jj_consume_token(IDENTIFIER);
                                       System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > DT "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
          break;
        default:
          jj_la1[32] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CD:
        case VBG:
        case VBN:
        case JJ:
        case JJS:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case JJ:
            jj_consume_token(JJ);
            break;
          case JJS:
            jj_consume_token(JJS);
            break;
          case CD:
            jj_consume_token(CD);
            break;
          case VBG:
            jj_consume_token(VBG);
            break;
          case VBN:
            jj_consume_token(VBN);
            break;
          default:
            jj_la1[33] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          node = jj_consume_token(IDENTIFIER);
                                                                    System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > JJ "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
        }
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NN:
          case NNS:
          case NNP:
          case CD:
          case VBG:
          case JJ:
          case JJS:
          case PRP:
          case HYPH:
            ;
            break;
          default:
            jj_la1[35] = jj_gen;
            break label_4;
          }
          label_5:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case CD:
            case VBG:
            case JJ:
            case JJS:
              ;
              break;
            default:
              jj_la1[36] = jj_gen;
              break label_5;
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case JJ:
              jj_consume_token(JJ);
              break;
            case JJS:
              jj_consume_token(JJS);
              break;
            case CD:
              jj_consume_token(CD);
              break;
            case VBG:
              jj_consume_token(VBG);
              break;
            default:
              jj_la1[37] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            node = jj_consume_token(IDENTIFIER);
                                                                  System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > JJ "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case HYPH:
            jj_consume_token(HYPH);
            node = jj_consume_token(IDENTIFIER);
                                                 System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > JJ "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
            jj_consume_token(VBN);
            node = jj_consume_token(IDENTIFIER);
                                                 System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > JJ "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
            break;
          default:
            jj_la1[38] = jj_gen;
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NN:
            jj_consume_token(NN);
            break;
          case NNS:
            jj_consume_token(NNS);
            break;
          case NNP:
            jj_consume_token(NNP);
            break;
          case PRP:
            jj_consume_token(PRP);
            break;
          default:
            jj_la1[39] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          node = jj_consume_token(IDENTIFIER);
                          System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > NN NNS "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CC:
            jj_consume_token(CC);
            node = jj_consume_token(IDENTIFIER);
                                               System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > DT "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
            break;
          default:
            jj_la1[40] = jj_gen;
            ;
          }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VB:
        case VBD:
        case VBN:
        case VBP:
        case VBZ:
          verb();
          break;
        default:
          jj_la1[41] = jj_gen;
          ;
        }
        break;
      case PDT:
        jj_consume_token(PDT);
        node = jj_consume_token(IDENTIFIER);
                                  System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > PDT "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal=node.image;
        jj_consume_token(DT);
        node = jj_consume_token(IDENTIFIER);
                                 System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > DT "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
        jj_consume_token(NN);
        node = jj_consume_token(IDENTIFIER);
                                 System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5< temporal > NN "+node.image);return_String= appendString(return_String,"< temporal >",node.image);  temporal+=" "+node.image;
        break;
      case RP:
        jj_consume_token(RP);
        //识别副词
                node = jj_consume_token(IDENTIFIER);
                               System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5\uff1a< temporal > RP "+node.image); return_String= appendString(return_String,"< temporal >",node.image); temporal=node.image;
        break;
      case TOPRE:
        to_prep();
        jj_consume_token(RP);
        //识别副词
          node = jj_consume_token(IDENTIFIER);
                         System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5\uff1a< temporal > RP "+node.image); return_String= appendString(return_String,"< temporal >",node.image); temporal=node.image;
        jj_consume_token(RB);
        //识别副词
                node = jj_consume_token(IDENTIFIER);
                               System.out.println("\u65f6\u5e8f\u77ed\u8bedtemporal()\u65b9\u6cd5\uff1a< temporal > RP "+node.image); return_String= appendString(return_String,"< temporal >",node.image); temporal=node.image;
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
  System.out.println("temporal = "+temporal);
  {if (true) return temporal;}
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
*/





/**
*******************************************************************************************
*substantive() 分析的是 SBAR下去掉连接词的句子的主语
*
*这里添加字符串处太冗余，需要修改
*
*识别顺序为  (<PRP>)?  |  (< CD >|< DT >)？  +   (< VBD >|< VBG >|< VBN >|< VBP >)|(< JJ >|< JJS >)  ？  +   (< NN >|< NNS >)*
*
*Chunyi Li  添加  (<PRP>)?  （人称代词）作为主语的情况
* 单独添加形容词，过去分词/正在进行时作形容词时候不会被识别为VBD，而是被识别为JJ，并更改形容词识别程序。
* 
* 补充 the .. of .. 情况，此处需要增加对宾补和of的判断.，
*

*添加< RB >
补充< CC >
*/
  static final public void subject() throws ParseException {
   Token node;
   String principal_class_string = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRP:
      jj_consume_token(PRP);
      node = jj_consume_token(IDENTIFIER);
            System.out.println("\u4e3b\u8bed\u7684subject()\uff0c\u6709\u4eba\u79f0\u4ee3\u8bcd\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
           return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
           sub_String= appendString(sub_String,"< SUBSTANTIVE >",
           node.image);
      break;
    case NN:
    case NNS:
    case NNP:
    case CD:
    case VBG:
    case VBN:
    case JJ:
    case JJS:
    case JJR:
    case RB:
    case DT:
    case HYPH:
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CD:
        case DT:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CD:
            jj_consume_token(CD);
            break;
          case DT:
            jj_consume_token(DT);
            break;
          default:
            jj_la1[44] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          node = jj_consume_token(IDENTIFIER);
                    System.out.println("\u4e3b\u8bed\u7684subject()\uff0c\u4ece\u6570\u8bcd\u6216\u8005\u51a0\u8bcd\u5f00\u59cb\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                   return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                   sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
          break;
        default:
          jj_la1[45] = jj_gen;
          ;
        }
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case JJ:
          case JJS:
          case JJR:
            ;
            break;
          default:
            jj_la1[46] = jj_gen;
            break label_7;
          }
                   System.out.println("\u8fdb\u5165\u8fd9\u5f62\u5bb9\u8bcd\u91cc\u9762");
          adjective();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CC:
            jj_consume_token(CC);
            node = jj_consume_token(IDENTIFIER);
                  System.out.println("\u8fdb\u5165\u8fd9\u5f62\u5bb9\u8bcd\u5e76\u5217\u91cc\u9762");
                 System.out.println("\u4e3b\u8bed\u7684subject()\uff0c\u6709\u5206\u8bcd\u4f5c\u5f62\u5bb9\u8bcd\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
            adjective();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case JJ:
            case JJS:
            case JJR:
              adjective();
              break;
            default:
              jj_la1[47] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[48] = jj_gen;
            ;
          }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VBG:
          jj_consume_token(VBG);
          node = jj_consume_token(IDENTIFIER);
                 System.out.println("\u4e3b\u8bed\u7684subject()\uff0c\u6709\u5206\u8bcd\u4f5c\u5f62\u5bb9\u8bcd\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
          break;
        default:
          jj_la1[49] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HYPH:
          jj_consume_token(HYPH);
          node = jj_consume_token(IDENTIFIER);
                 System.out.println("\u4e3b\u8bed\u7684subject()\uff0c\u6709\u5206\u8bcd\u4f5c\u5f62\u5bb9\u8bcd\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
          break;
        default:
          jj_la1[50] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NN:
          jj_consume_token(NN);
          break;
        case NNS:
          jj_consume_token(NNS);
          break;
        case VBN:
          jj_consume_token(VBN);
          break;
        case RB:
          jj_consume_token(RB);
          break;
        case NNP:
          jj_consume_token(NNP);
          break;
        default:
          jj_la1[51] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        node = jj_consume_token(IDENTIFIER);
                                        System.out.println("\u4e3b\u8bed\u7684subject()\uff0c\u4e3b\u8bed\u4e0d\u662f\u4ee3\u8bcd\u65f6\u5fc5\u987b\u81f3\u5c11\u6709\u4e00\u4e2a\u540d\u8bcd"+"< substantive > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                 sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
                 principal_class_string = appendString(principal_class_string,"< SUBSTANTIVE >",node.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IN:
          preposition();
          break;
        default:
          jj_la1[52] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CC:
        case IDENTIFIER:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CC:
            jj_consume_token(CC);
            break;
          default:
            jj_la1[53] = jj_gen;
            ;
          }
          node = jj_consume_token(IDENTIFIER);
                 System.out.println("\u4e3b\u8bed\u7684subject()\uff0c\u6709\u8fde\u8bcd\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
        principal_class_string = appendString(principal_class_string,"< SUBSTANTIVE >",node.image);
          break;
        default:
          jj_la1[54] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NN:
        case NNS:
        case NNP:
        case CD:
        case VBG:
        case VBN:
        case JJ:
        case JJS:
        case JJR:
        case RB:
        case DT:
        case HYPH:
          ;
          break;
        default:
          jj_la1[55] = jj_gen;
          break label_6;
        }
      }
        principal_class.add(principal_class_string);
      break;
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
*******************************************************************************************
*/







/**
*****************************************************************************************************************************
*****************************************************************************************************************************
*******************************************************************************************************************************
*这里是宾语的提取
*

*/
  static final public void object() throws ParseException {
   Token node;
   String attribute_class_string = "";
   String tmp = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRP:
     System.out.println("1onject()\u904d\u5386\u5f00\u59cb---------------------------------");
      jj_consume_token(PRP);
      node = jj_consume_token(IDENTIFIER);
            System.out.println("2object()\u5bbe\u8bed\u7684subject()\uff0c\u6709\u4eba\u79f0\u4ee3\u8bcd\u4e3a\uff1a"+node.image+",");
           return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
           sub_String= appendString(sub_String,"< SUBSTANTIVE >",
           node.image);
       attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",node.image);
      break;
    case NN:
    case NNS:
    case NNP:
    case CD:
    case VBD:
    case VBG:
    case VBN:
    case JJ:
    case JJS:
    case JJR:
    case RB:
    case DT:
    case HYPH:
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RB:
          jj_consume_token(RB);
          node = jj_consume_token(IDENTIFIER);
                   System.out.println("3\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u4e13\u6709\u540d\u8bcd"+"< VBG > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< VBG >",node.image);
                 sub_String= appendString(sub_String,"< VBG >",node.image);
         attribute_class_string = appendString(attribute_class_string,"< HYPH >",node.image);
          break;
        default:
          jj_la1[57] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VBD:
        case VBG:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case VBG:
            jj_consume_token(VBG);
            break;
          case VBD:
            jj_consume_token(VBD);
            break;
          default:
            jj_la1[58] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          node = jj_consume_token(IDENTIFIER);
                 System.out.println("4object()\u5bbe\u8bed\u6709\u8fc7\u53bb\u5206\u8bcd\u505a\u5f62\u5bb9\u8bcd\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+"\u3002");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
        attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",node.image);
          break;
        default:
          jj_la1[59] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CD:
        case DT:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CD:
            jj_consume_token(CD);
            break;
          case DT:
            jj_consume_token(DT);
            break;
          default:
            jj_la1[60] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          node = jj_consume_token(IDENTIFIER);
                    System.out.println("5object()\u5bbe\u8bed\uff0c\u4ece\u6570\u8bcd\u6216\u8005\u51a0\u8bcd\u5f00\u59cb\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",");
                   return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                   sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
           attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",node.image);
          break;
        default:
          jj_la1[61] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case JJ:
        case JJS:
        case JJR:
                   System.out.println("6object()\u5bbe\u8bed\u5982\u679c\u6709\u5f62\u5bb9\u8bcd\u91cc\u9762");
          tmp = adjective_object();
           attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",tmp);
          break;
        default:
          jj_la1[62] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VBG:
          jj_consume_token(VBG);
          node = jj_consume_token(IDENTIFIER);
                 System.out.println("7object()\u5bbe\u8bed\u6709\u8fc7\u53bb\u5206\u8bcd\u505a\u5f62\u5bb9\u8bcd\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+"\u3002");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
        attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",node.image);
          break;
        default:
          jj_la1[63] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case HYPH:
          jj_consume_token(HYPH);
          node = jj_consume_token(IDENTIFIER);
                 System.out.println("8object()\u5bbe\u8bed\u7684\u7279\u6b8a\u540d\u8bcd\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
        attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",node.image);
          break;
        default:
          jj_la1[64] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case JJ:
        case JJS:
        case JJR:
          tmp = adjective_object();
          break;
        default:
          jj_la1[65] = jj_gen;
          ;
        }
                  attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",tmp);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case JJ:
        case JJS:
        case JJR:
          tmp = adjective_object();
          break;
        default:
          jj_la1[66] = jj_gen;
          ;
        }
                  attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",tmp);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NN:
          jj_consume_token(NN);
          break;
        case NNS:
          jj_consume_token(NNS);
          break;
        case VBN:
          jj_consume_token(VBN);
          break;
        case RB:
          jj_consume_token(RB);
          break;
        case NNP:
          jj_consume_token(NNP);
          break;
        default:
          jj_la1[67] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        node = jj_consume_token(IDENTIFIER);
                  System.out.println("13object()\u5bbe\u8bed\u7684\u4e0d\u662f\u4ee3\u8bcd\u65f6\u5fc5\u987b\u81f3\u5c11\u6709\u4e00\u4e2a\u540d\u8bcd"+" < NN > NOUN "+node.image);
                  return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                  sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
                  attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",node.image);
                            System.out.println("object()\u5bbe\u8bed\u5b58\u5728of\u60c5\u51b5");
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CC:
          jj_consume_token(CC);
          node = jj_consume_token(IDENTIFIER);
                                 System.out.println("\u5bbe\u8bed\u7684\u5982\u679c\u6709\u540d\u8bcd\u5e76\u5217\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
                        attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",node.image);
          break;
        default:
          jj_la1[68] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NN:
        case NNS:
        case NNP:
        case CD:
        case VBD:
        case VBG:
        case VBN:
        case JJ:
        case JJS:
        case JJR:
        case RB:
        case DT:
        case HYPH:
          ;
          break;
        default:
          jj_la1[69] = jj_gen;
          break label_8;
        }
      }
   attribute_class.add(attribute_class_string);
   System.out.println("object()\u904d\u5386\u5b8c\u6bd5");
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
*******************************************************************************************
* 宾语中的形容词
*/
  static final public String adjective_object() throws ParseException {
  Token node;
  String attribute_class_string = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case JJ:
      jj_consume_token(JJ);
      break;
    case JJS:
      jj_consume_token(JJS);
      break;
    case JJR:
      jj_consume_token(JJR);
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    node = jj_consume_token(IDENTIFIER);
                         System.out.println("\u5bbe\u8bed\u4e2d\u7684< ADJECTIVE >  "+node.image);
  return_String = appendString(return_String,"< ADJECTIVE >",node.image);
  sub_String = appendString(sub_String,"< ADJECTIVE >",node.image);
  {if (true) return attribute_class_string;}
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************
* 宾语中的介词
*/
  static final public String preposition_object() throws ParseException {
  Token node;
  String attribute_class_string = "";
     System.out.println("preposition_object()\u904d\u5386\u5f00\u59cb---------------------------------");
    jj_consume_token(IN);
    node = jj_consume_token(IDENTIFIER);
   if(node.image.equals("of"))
   {
         System.out.println("\u5bbe\u8bed\u4e2d\u7684\u4ecb\u8bcd\u7684preposition()\u65b9\u6cd5 < IN > preposition   "+node.image);
         return_String = appendString(return_String,"< IN > preposition",node.image);
         sub_String = appendString(sub_String,"< IN > preposition",node.image);
         attribute_class_string = appendString(attribute_class_string,"< SUBSTANTIVE >",node.image);
         {if (true) return attribute_class_string;}
        }else
        {
          {if (true) return "";}
        }
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*/
/**
*******************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
作用对象方法

*/
  static final public void action_scope() throws ParseException {
   Token node;
   String action_scope_class_string = "";
   String tmp = "";
    System.out.println("action_scope()\u904d\u5386\u5f00\u59cb-------------------------------------------------");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      jj_consume_token(IN);
      break;
    case TOPRE:
      jj_consume_token(TOPRE);
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VB:
        jj_consume_token(VB);
        break;
      case DT:
        jj_consume_token(DT);
        jj_consume_token(IDENTIFIER);
        jj_consume_token(NN);
        break;
      case NN:
        jj_consume_token(NN);
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CC:
          jj_consume_token(CC);
          jj_consume_token(IDENTIFIER);
          jj_consume_token(VB);
          break;
        case DT:
          jj_consume_token(DT);
          jj_consume_token(IDENTIFIER);
          jj_consume_token(NN);
          break;
        case NN:
          jj_consume_token(NN);
          break;
        default:
          jj_la1[73] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[74] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[75] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    node = jj_consume_token(IDENTIFIER);
                 System.out.println("1\u4f5c\u7528\u5bf9\u8c61\u4e2d\u7684\u4ecb\u8bcd < IN > preposition   "+node.image);
                 return_String = appendString(return_String,"< IN > preposition",node.image);
                 sub_String = appendString(sub_String,"< IN > preposition",node.image);
                 action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VBG:
      case VBN:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VBG:
          jj_consume_token(VBG);
          break;
        case VBN:
          jj_consume_token(VBN);
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        node = jj_consume_token(IDENTIFIER);
                   System.out.println("2\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u4e13\u6709\u540d\u8bcd"+"< VBG > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< VBG >",node.image);
                 sub_String= appendString(sub_String,"< VBG >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< HYPH >",node.image);
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IN:
      case TOPRE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IN:
          jj_consume_token(IN);
          break;
        case TOPRE:
          jj_consume_token(TOPRE);
          jj_consume_token(IDENTIFIER);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case VB:
            jj_consume_token(VB);
            break;
          case NN:
            jj_consume_token(NN);
            break;
          default:
            jj_la1[78] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[79] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        node = jj_consume_token(IDENTIFIER);
                 System.out.println("3\u4f5c\u7528\u5bf9\u8c61\u4e2d\u7684\u4ecb\u8bcd < IN > preposition   "+node.image);
                 return_String = appendString(return_String,"< IN > preposition",node.image);
                 sub_String = appendString(sub_String,"< IN > preposition",node.image);
                 action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        break;
      default:
        jj_la1[80] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CC:
        jj_consume_token(CC);
        node = jj_consume_token(IDENTIFIER);
                 System.out.println("3-1-1\u4f5c\u7528\u5bf9\u8c61\u5982\u679c\u6709\u540d\u8bcd\u5e76\u5217\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
        action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VB:
          jj_consume_token(VB);
          break;
        case VBG:
          jj_consume_token(VBG);
          break;
        case IN:
          jj_consume_token(IN);
          break;
        default:
          jj_la1[81] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        node = jj_consume_token(IDENTIFIER);
                 System.out.println("3-1\u4f5c\u7528\u5bf9\u8c61\u4e2d\u7684\u4ecb\u8bcd < IN > preposition   "+node.image);
                 return_String = appendString(return_String,"< IN > preposition",node.image);
                 sub_String = appendString(sub_String,"< IN > preposition",node.image);
                 action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        break;
      default:
        jj_la1[82] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RBS:
        jj_consume_token(RBS);
        node = jj_consume_token(IDENTIFIER);
                    System.out.println("4\u4f5c\u7528\u5bf9\u8c61\u4ece\u6570\u8bcd\u6216\u8005\u51a0\u8bcd\u5f00\u59cb\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",");
                   return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                   sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
           action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        break;
      default:
        jj_la1[83] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD:
      case DT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CD:
          jj_consume_token(CD);
          break;
        case DT:
          jj_consume_token(DT);
          break;
        default:
          jj_la1[84] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        node = jj_consume_token(IDENTIFIER);
                    System.out.println("5\u4f5c\u7528\u5bf9\u8c61\u4ece\u6570\u8bcd\u6216\u8005\u51a0\u8bcd\u5f00\u59cb\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",");
                   return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                   sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
           action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        break;
      default:
        jj_la1[85] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case JJ:
      case JJS:
      case JJR:
        tmp = adjective_action_scope();
                  action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",tmp);
        break;
      default:
        jj_la1[86] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case JJ:
      case JJS:
      case JJR:
        tmp = adjective_action_scope();
                  action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",tmp);
        break;
      default:
        jj_la1[87] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VBG:
        jj_consume_token(VBG);
        node = jj_consume_token(IDENTIFIER);
                   System.out.println("6\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u4e13\u6709\u540d\u8bcd"+"< VBG > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< VBG >",node.image);
                 sub_String= appendString(sub_String,"< VBG >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< HYPH >",node.image);
        break;
      default:
        jj_la1[88] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VBG:
        jj_consume_token(VBG);
        node = jj_consume_token(IDENTIFIER);
                   System.out.println("7\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u4e13\u6709\u540d\u8bcd"+"< VBG > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< VBG >",node.image);
                 sub_String= appendString(sub_String,"< VBG >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< HYPH >",node.image);
        break;
      default:
        jj_la1[89] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case JJ:
      case JJS:
      case JJR:
        tmp = adjective_action_scope();
                  action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",tmp);
        break;
      default:
        jj_la1[90] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DT:
        jj_consume_token(DT);
        node = jj_consume_token(IDENTIFIER);
                   System.out.println("8\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u4e13\u6709\u540d\u8bcd"+"< DT > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< DT >",node.image);
                 sub_String= appendString(sub_String,"< DT >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< DT >",node.image);
        break;
      default:
        jj_la1[91] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CC:
        jj_consume_token(CC);
        node = jj_consume_token(IDENTIFIER);
                 System.out.println("9\u4f5c\u7528\u5bf9\u8c61\u5982\u679c\u6709\u540d\u8bcd\u5e76\u5217\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
        action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        tmp = adjective_action_scope();
                  action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",tmp);
        break;
      default:
        jj_la1[92] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NN:
        jj_consume_token(NN);
        break;
      case NNS:
        jj_consume_token(NNS);
        break;
      case VBN:
        jj_consume_token(VBN);
        break;
      case RB:
        jj_consume_token(RB);
        break;
      case NNP:
        jj_consume_token(NNP);
        break;
      case PRP:
        jj_consume_token(PRP);
        break;
      default:
        jj_la1[93] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      node = jj_consume_token(IDENTIFIER);
                   System.out.println("10\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u5fc5\u987b\u81f3\u5c11\u6709\u4e00\u4e2a\u540d\u8bcd"+"< substantive > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                 sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case HYPH:
        jj_consume_token(HYPH);
        node = jj_consume_token(IDENTIFIER);
                   System.out.println("11\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u4e13\u6709\u540d\u8bcd"+"< HYPH > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< HYPH >",node.image);
                 sub_String= appendString(sub_String,"< HYPH >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< HYPH >",node.image);
        break;
      default:
        jj_la1[94] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRP:
        jj_consume_token(PRP);
        node = jj_consume_token(IDENTIFIER);
                   System.out.println("12\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u4e13\u6709\u540d\u8bcd"+"< HYPH > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< HYPH >",node.image);
                 sub_String= appendString(sub_String,"< HYPH >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< HYPH >",node.image);
        break;
      default:
        jj_la1[95] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD:
        jj_consume_token(CD);
        node = jj_consume_token(IDENTIFIER);
                   System.out.println("13\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u4e13\u6709\u540d\u8bcd"+"< DT > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< DT >",node.image);
                 sub_String= appendString(sub_String,"< DT >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< DT >",node.image);
        break;
      default:
        jj_la1[96] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CC:
      case IDENTIFIER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CC:
          jj_consume_token(CC);
          break;
        default:
          jj_la1[97] = jj_gen;
          ;
        }
        node = jj_consume_token(IDENTIFIER);
                 System.out.println("14\u4f5c\u7528\u5bf9\u8c61\u5982\u679c\u6709\u540d\u8bcd\u5e76\u5217\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
        action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        break;
      default:
        jj_la1[98] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD:
        jj_consume_token(CD);
        node = jj_consume_token(IDENTIFIER);
                   System.out.println("15\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u4e13\u6709\u540d\u8bcd"+"< CD > < CD > NOUN "+node.image);
                 return_String=appendString(return_String,"< CD >",node.image);
                 sub_String= appendString(sub_String,"< CD >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< CD >",node.image);
        break;
      default:
        jj_la1[99] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NN:
      case NNS:
      case NNP:
      case CD:
      case CC:
      case RBS:
      case VBG:
      case VBN:
      case IN:
      case JJ:
      case JJS:
      case JJR:
      case RB:
      case DT:
      case PRP:
      case TOPRE:
        ;
        break;
      default:
        jj_la1[100] = jj_gen;
        break label_9;
      }
    }
    System.out.println("action_scope()\u904d\u5386\u5b8c\u6bd5-------------------------------------------------");
        action_scope_class.add(action_scope_class_string);
  }

/**
*******************************************************************************************
* 作用域中的形容词
*/
  static final public String adjective_action_scope() throws ParseException {
  Token node;
  String action_scope_class = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case JJ:
      jj_consume_token(JJ);
      break;
    case JJS:
      jj_consume_token(JJS);
      break;
    case JJR:
      jj_consume_token(JJR);
      break;
    default:
      jj_la1[101] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    node = jj_consume_token(IDENTIFIER);
                         System.out.println("\u4f5c\u7528\u57df\u4e2d\u5bbe\u8bed\u4e2d\u7684< ADJECTIVE >  "+node.image);
  return_String = appendString(return_String,"< ADJECTIVE >",node.image);
  sub_String = appendString(sub_String,"< ADJECTIVE >",node.image);
  {if (true) return action_scope_class;}
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************************************************
*****************************************************************************************************************************
*****************************************************************************************************************************
*/




/**
*******************************************************************************************
*在treenode clause中的谓语识别
*
*识别顺序为   情态动词（有无都可）+谓语动词predicate()
*如果有情态动词 will shall 时间标记为1   如果不是则return_String 加入情态动词   sub_String不加情态动词
*
*此处应该考虑 will  和  would的时态问题，需要扩展
*加入 will not情况
*/
  static final public boolean predicates() throws ParseException {
  boolean mark=false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MD:
      mark = modality();
      break;
    default:
      jj_la1[102] = jj_gen;
      ;
    }
           System.out.println("\u4e3b\u6b21\u8868\u7ed3\u6784\u904d\u5386\u5b8c");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RB:
    case RP:
      adverb();
      break;
    default:
      jj_la1[103] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RB:
    case RP:
      adverb();
      break;
    default:
      jj_la1[104] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VB:
    case VBD:
    case VBG:
    case VBN:
    case VBP:
    case VBZ:
      predicate();
      break;
    default:
      jj_la1[105] = jj_gen;
      ;
    }
                                                   System.out.println("\u4e3b\u8c13\u5bbe\u7ed3\u6784\u8c13\u8bed\u904d\u5386\u5b8c");  {if (true) return mark;}
         {if (true) return mark;}
    throw new Error("Missing return statement in function");
  }

  static final public boolean modality() throws ParseException {
  boolean mark=false;
  Token node;
    jj_consume_token(MD);
    node = jj_consume_token(IDENTIFIER);
    System.out.println("modality()\u65b9\u6cd5\u4e2d\u8bc6\u522b\u7684\u60c5\u6001\u52a8\u8bcd\u4e3a< MODALITY MD >  "+node.image);
        return_String= appendString(return_String,"< MODALITY >",node.image);
        System.out.println("\u8bc6\u522b\u5b8c\u60c5\u6001\u52a8\u8bcd\uff0c\u6b64\u65f6return_String\u7684\u503c\u4e3a"+node.image);
        if(node.image.equals("will")||node.image.equals("shall")){
        }
        else{
                {if (true) return false;}
        }
     System.out.println("\u6d4b\u8bd5\u662f\u5426\u8fdb\u5165----------------------");
    predicate_copula();
    {if (true) return true;}
    throw new Error("Missing return statement in function");
  }

/**
*******************************************************************************************

***************************************为主系表所设立***************************************
*
*
*/
  static final public void predicate_copula() throws ParseException {
  Token node;
  String active_trigger_class_string ="";
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VB:
      case VBD:
      case VBG:
      case VBN:
      case VBP:
      case VBZ:
        ;
        break;
      default:
        jj_la1[106] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VBD:
        jj_consume_token(VBD);
        break;
      case VBG:
        jj_consume_token(VBG);
        break;
      case VBN:
        jj_consume_token(VBN);
        break;
      case VBP:
        jj_consume_token(VBP);
        break;
      case VBZ:
        jj_consume_token(VBZ);
        break;
      case VB:
        jj_consume_token(VB);
        break;
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      node = jj_consume_token(IDENTIFIER);
    System.out.println("\u4e3b\u7cfb\u8868\u4e2d\u52a8\u8bcd\u505a\u8868\u8bed\u7684\u52a8\u8bcd\u60c5\u51b5 < PARTICIPLE > VERB   "+node.image);
  return_String = appendString(return_String,"< PARTICIPLE >",node.image);
  sub_String = appendString(sub_String,"< PARTICIPLE >",node.image);
  active_trigger_class_string = appendString(active_trigger_class_string,"< VERB >",node.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VBN:
      case JJ:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VBN:
          jj_consume_token(VBN);
          break;
        case JJ:
          jj_consume_token(JJ);
          break;
        default:
          jj_la1[108] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        node = jj_consume_token(IDENTIFIER);
    System.out.println("\u4e3b\u7cfb\u8868\u4e2d\u52a8\u8bcd/JJ\u505a\u8868\u8bed\u7684be\u52a8\u8bcd\u60c5\u51b5 < PARTICIPLE > VERB   "+node.image);
  return_String = appendString(return_String,"< PARTICIPLE >",node.image);
  sub_String = appendString(sub_String,"< PARTICIPLE >",node.image);
  active_trigger_class_string = appendString(active_trigger_class_string,"< VERB >",node.image);
        break;
      default:
        jj_la1[109] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CC:
        jj_consume_token(CC);
        node = jj_consume_token(IDENTIFIER);
   System.out.println("\u65f6\u4e3b\u7cfb\u8868\u4e2d\u52a8\u8bcd\u6709\u591a\u4e2a\u8868\u8bed\u7684\u60c5\u51b5 "+node.image);
  return_String = appendString(return_String,"< PARTICIPLE >",node.image);
  sub_String = appendString(sub_String,"< PARTICIPLE >",node.image);
  active_trigger_class_string = appendString(active_trigger_class_string,"< VERB >",node.image);
        break;
      default:
        jj_la1[110] = jj_gen;
        ;
      }
    }
active_trigger_class.add(active_trigger_class_string);
  }

  static final public void prepositional_phrase_copula() throws ParseException {
   Token node;
   String action_scope_class_string = "";
   String tmp = "";
    jj_consume_token(IN);
    node = jj_consume_token(IDENTIFIER);
                 System.out.println("\u4e3b\u7cfb\u8868\u4e2d\u4f5c\u7528\u5bf9\u8c61\u4e2d\u7684\u4ecb\u8bcd < IN > preposition   "+node.image);
                 return_String = appendString(return_String,"< IN > preposition",node.image);
                 sub_String = appendString(sub_String,"< IN > preposition",node.image);
                 action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NN:
      case NNS:
      case NNP:
      case CD:
      case VBN:
      case JJ:
      case RB:
      case DT:
        ;
        break;
      default:
        jj_la1[112] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CD:
      case DT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CD:
          jj_consume_token(CD);
          break;
        case DT:
          jj_consume_token(DT);
          break;
        default:
          jj_la1[113] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        node = jj_consume_token(IDENTIFIER);
                    System.out.println("\u4e3b\u7cfb\u8868\u4e2d\u4f5c\u7528\u5bf9\u8c61\u4ece\u6570\u8bcd\u6216\u8005\u51a0\u8bcd\u5f00\u59cb\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",");
                   return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                   sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
           action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        break;
      default:
        jj_la1[114] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case JJ:
        jj_consume_token(JJ);
        node = jj_consume_token(IDENTIFIER);
                    System.out.println("\u4e3b\u7cfb\u8868\u4e2d\u4f5c\u7528\u5bf9\u8c61\u4ece\u6570\u8bcd\u6216\u8005\u51a0\u8bcd\u5f00\u59cb\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",");
                   return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                   sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
           action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        break;
      default:
        jj_la1[115] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NN:
        jj_consume_token(NN);
        break;
      case NNS:
        jj_consume_token(NNS);
        break;
      case VBN:
        jj_consume_token(VBN);
        break;
      case RB:
        jj_consume_token(RB);
        break;
      case NNP:
        jj_consume_token(NNP);
        break;
      default:
        jj_la1[116] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      node = jj_consume_token(IDENTIFIER);
                   System.out.println("\u4e3b\u7cfb\u8868\u4e2d\u7684\u4f5c\u7528\u5bf9\u8c61\u4e0d\u662f\u4ee3\u8bcd\u65f6\u5fc5\u987b\u81f3\u5c11\u6709\u4e00\u4e2a\u540d\u8bcd"+"< substantive > < NN > NOUN "+node.image);
                 return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                 sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
         action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CC:
        jj_consume_token(CC);
        node = jj_consume_token(IDENTIFIER);
                 System.out.println("\u4e3b\u7cfb\u8868\u4e2d\u4f5c\u7528\u5bf9\u8c61\u5982\u679c\u6709\u540d\u8bcd\u5e76\u5217\uff0c\u5982\u679c\u6709\u4e3a\uff1a"+node.image+",\u6216\u8005\u6ca1\u6709\u4e5f\u884c");
                return_String=appendString(return_String,"< SUBSTANTIVE >",node.image);
                sub_String= appendString(sub_String,"< SUBSTANTIVE >",node.image);
        action_scope_class_string = appendString(action_scope_class_string,"< SUBSTANTIVE >",node.image);
        break;
      default:
        jj_la1[117] = jj_gen;
        ;
      }
    }
    System.out.println("\u4e3b\u7cfb\u8868\u4e2d\u5b58\u5728\u4f5c\u7528\u57df\u904d\u5386\u5b8c\u6bd5\u4e86");
    if(action_scope_class_string!="")
    {
        action_scope_class.add(action_scope_class_string);
    }
  }

/**
*******************************************************************************************

******************************************************************************
*
*
*/



/**
*******************************************************************************************
*在treenode clause中的不带情态动词谓语识别
*
*识别顺序为
（1）(< VB >|< VBD >|< VBN >|< VBP >|< VBZ >)(< RP >)? +  数字0 | 数字1-9 （0|...|9）* （%）？| true
（2）(< VBD >|< VBG >|< VBN >|< VBP >)
*li ge工作将数词变为动词作谓语的一部分，此处用的?所以不需要一定删除
*  node=< BE > { System.out.println("< BE >be  "+node.image);return_String= appendString(return_String,"< BE >",node.image); sub_String= appendString(sub_String,"< BE >",node.image);}
*  此处有问题 is 为关键字，前面编辑也是<VBZ>，应该先遍历<VBZ>这样的标签再判断
* 补充 过去分词中间有RB修饰的情况， 例如 is only enable的情况
*
*
*/
  static final public void predicate() throws ParseException {
  Token node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VBD:
    case VBG:
    case VBN:
    case VBP:
    case VBZ:
      be();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RB:
      case RP:
        adverb();
        break;
      default:
        jj_la1[118] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VBD:
      case VBG:
      case VBN:
      case VBP:
      case JJ:
      case JJS:
      case JJR:
      case RB:
      case RP:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VBD:
        case VBG:
        case VBN:
        case VBP:
          participle();
          break;
        case JJ:
        case JJS:
        case JJR:
        case RB:
        case RP:
          complement();
          break;
        default:
          jj_la1[119] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[120] = jj_gen;
        ;
      }
      break;
    case VB:
      verb();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case JJ:
      case JJS:
      case JJR:
        is_adjective();
        break;
      default:
        jj_la1[121] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VBD:
      case VBG:
      case VBN:
      case VBP:
        participle();
        break;
      default:
        jj_la1[122] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[123] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
*******************************************************************************************
*去掉原有BE IS ARE的关键词声明,改用NLP标签的声明
*添加 is 所对应的 < VBZ > 标签

添加 be 所对应< VB > 标签 verb()adj()
*
*/
  static final public void be() throws ParseException {
  Token node;
  String active_trigger_class_string ="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VBD:
      jj_consume_token(VBD);
      break;
    case VBG:
      jj_consume_token(VBG);
      break;
    case VBN:
      jj_consume_token(VBN);
      break;
    case VBP:
      jj_consume_token(VBP);
      break;
    case VBZ:
      jj_consume_token(VBZ);
      break;
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    node = jj_consume_token(IDENTIFIER);
                         System.out.println("1be() \u65b9\u6cd5\u4e2d\u7684< PARTICIPLE > VERB   "+node.image);
  return_String = appendString(return_String,"< PARTICIPLE >",node.image);
  sub_String = appendString(sub_String,"< PARTICIPLE >",node.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RB:
      jj_consume_token(RB);
      node = jj_consume_token(IDENTIFIER);
    System.out.println("2be() \u65b9\u6cd5\u4e2d\u7684< PARTICIPLE > VERB   "+node.image);
  return_String = appendString(return_String,"< PARTICIPLE >",node.image);
  sub_String = appendString(sub_String,"< PARTICIPLE >",node.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VB:
        jj_consume_token(VB);
        break;
      case JJ:
        jj_consume_token(JJ);
        break;
      case VBN:
        jj_consume_token(VBN);
        break;
      default:
        jj_la1[125] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      node = jj_consume_token(IDENTIFIER);
    System.out.println("3be() \u65b9\u6cd5\u4e2d\u7684< PARTICIPLE > VERB   "+node.image);
  return_String = appendString(return_String,"< PARTICIPLE >",node.image);
  sub_String = appendString(sub_String,"< PARTICIPLE >",node.image);
      break;
    default:
      jj_la1[126] = jj_gen;
      ;
    }
  if(node.image.equals("is")||node.image.equals("are")||node.image.equals("am")||node.image.equals("was")||node.image.equals("were")||node.image.equals("be"))
  {
  }else {
  active_trigger_class_string = appendString(active_trigger_class_string,"< VERB >",node.image);
  active_trigger_class.add(active_trigger_class_string);
  }
  }

  static final public void complement() throws ParseException {
  Token node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case JJ:
    case JJS:
    case JJR:
      is_adjective();
      break;
    case RB:
    case RP:
      adverb();
      break;
    default:
      jj_la1[127] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
*******************************************************************************************
* LI ge此段程序错误，识别主语时候无法识别形容词，已更改。
*加入< RB > < JJ >的情况
*/
  static final public void adjective() throws ParseException {
  Token node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case JJ:
      jj_consume_token(JJ);
      break;
    case JJS:
      jj_consume_token(JJS);
      break;
    case JJR:
      jj_consume_token(JJR);
      break;
    default:
      jj_la1[128] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    node = jj_consume_token(IDENTIFIER);
                         System.out.println("adjective()\u4e2d\u7684< ADJECTIVE >  "+node.image);
  return_String = appendString(return_String,"< ADJECTIVE >",node.image);
  sub_String = appendString(sub_String,"< ADJECTIVE >",node.image);
  }

  static final public void is_adjective() throws ParseException {
  Token node;
  String active_trigger_class_string ="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case JJ:
      jj_consume_token(JJ);
      break;
    case JJS:
      jj_consume_token(JJS);
      break;
    case JJR:
      jj_consume_token(JJR);
      break;
    default:
      jj_la1[129] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    node = jj_consume_token(IDENTIFIER);
                         System.out.println("is_adjective()\u4e2d\u7684< ADJECTIVE >  "+node.image);
  return_String = appendString(return_String,"< ADJECTIVE >",node.image);
  sub_String = appendString(sub_String,"< ADJECTIVE >",node.image);
  active_trigger_class_string = appendString(active_trigger_class_string,"< PARTICIPLE >",node.image);
  active_trigger_class.add(active_trigger_class_string);
  }

  static final public void adverb() throws ParseException {
  Token node;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RB:
      jj_consume_token(RB);
      break;
    case RP:
      jj_consume_token(RP);
      break;
    default:
      jj_la1[130] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    node = jj_consume_token(IDENTIFIER);
                        System.out.println("< RB > ADVERB RB   "+node.image); return_String = appendString(return_String,"< ADVERB >",node.image); sub_String = appendString(sub_String,"< ADVERB >",node.image);
  }

  static final public void preposition() throws ParseException {
  Token node;
    jj_consume_token(IN);
    node = jj_consume_token(IDENTIFIER);
                        System.out.println("\u4ecb\u8bcd\u7684preposition()\u65b9\u6cd5 < IN > preposition   "+node.image); return_String = appendString(return_String,"< IN > preposition",node.image); sub_String = appendString(sub_String,"< IN > preposition",node.image);
  }

  static final public void participle() throws ParseException {
   Token node;
   String active_trigger_class_string ="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VBD:
      jj_consume_token(VBD);
      break;
    case VBG:
      jj_consume_token(VBG);
      break;
    case VBN:
      jj_consume_token(VBN);
      break;
    case VBP:
      jj_consume_token(VBP);
      break;
    default:
      jj_la1[131] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    node = jj_consume_token(IDENTIFIER);
                         System.out.println("\u5206\u8bcd\u7684participle()\u65b9\u6cd5\u4e2d VERB   "+node.image);
  return_String = appendString(return_String,"< PARTICIPLE >",node.image);
  sub_String = appendString(sub_String,"< PARTICIPLE >",node.image);
  active_trigger_class_string = appendString(active_trigger_class_string,"< PARTICIPLE >",node.image);
  active_trigger_class.add(active_trigger_class_string);
  }

  static final public void verb() throws ParseException {
  Token node;
  String active_trigger_class_string ="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VB:
      jj_consume_token(VB);
      break;
    case VBD:
      jj_consume_token(VBD);
      break;
    case VBN:
      jj_consume_token(VBN);
      break;
    case VBP:
      jj_consume_token(VBP);
      break;
    case VBZ:
      jj_consume_token(VBZ);
      break;
    default:
      jj_la1[132] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RP:
      jj_consume_token(RP);
      break;
    default:
      jj_la1[133] = jj_gen;
      ;
    }
    node = jj_consume_token(IDENTIFIER);
    System.out.println("\u52a8\u8bcdverb() \u65b9\u6cd5\u4e2d< VB > VERB   "+node.image);
  return_String = appendString(return_String,"< VERB >",node.image);
  sub_String = appendString(sub_String,"< VERB >",node.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CC:
      jj_consume_token(CC);
      node = jj_consume_token(IDENTIFIER);
    System.out.println("\u52a8\u8bcdverb() \u65b9\u6cd5\u4e2d< VB > VERB   "+node.image);
  return_String = appendString(return_String,"< VERB >",node.image);
  sub_String = appendString(sub_String,"< VERB >",node.image);
      jj_consume_token(VB);
      node = jj_consume_token(IDENTIFIER);
    System.out.println("\u52a8\u8bcdverb() \u65b9\u6cd5\u4e2d< VB > VERB   "+node.image);
  return_String = appendString(return_String,"< VERB >",node.image);
  sub_String = appendString(sub_String,"< VERB >",node.image);
      break;
    default:
      jj_la1[134] = jj_gen;
      ;
    }
  if(node.image.equals("is")||node.image.equals("are")||node.image.equals("am")||node.image.equals("was")||node.image.equals("were")||node.image.equals("be"))
  {
  }else {
  active_trigger_class_string = appendString(active_trigger_class_string,"< VERB >",node.image);
  active_trigger_class.add(active_trigger_class_string);
  }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public FormulaParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[135];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x3e60fc00,0x3e68fc00,0x2000c00,0x0,0x3c60f000,0x0,0x0,0x3c60f000,0x0,0x0,0x3c60f000,0x22010000,0x22010000,0x22010000,0x2000c00,0x0,0x3c70f000,0x2000000,0x2000c00,0x22000000,0x2000c00,0x20000000,0x20000000,0x80000,0x80000,0x1000,0x1000,0x22010000,0x20000000,0x10000,0x0,0x20000000,0xc608000,0xc608000,0xc20f000,0xc208000,0xc208000,0x0,0x7000,0x10000,0x1d80000,0x2000000,0x22000000,0x8000,0x8000,0x1c000000,0x1c000000,0x10000,0x200000,0x0,0x20407000,0x2000000,0x10000,0x10000,0x3c60f000,0x3c60f000,0x20000000,0x300000,0x300000,0x8000,0x8000,0x1c000000,0x200000,0x0,0x1c000000,0x1c000000,0x20407000,0x10000,0x3c70f000,0x3c70f000,0x1c000000,0x81000,0x11000,0x0,0x2000000,0x600000,0x600000,0x81000,0x2000000,0x2000000,0x2280000,0x10000,0x20000,0x8000,0x8000,0x1c000000,0x1c000000,0x200000,0x200000,0x1c000000,0x0,0x10000,0x20407000,0x0,0x0,0x8000,0x10000,0x10000,0x8000,0x3e63f000,0x1c000000,0x40000,0x20000000,0x20000000,0x1f80000,0x1f80000,0x1f80000,0x4400000,0x4400000,0x10000,0x1c000000,0x2440f000,0x8000,0x8000,0x4000000,0x20407000,0x10000,0x20000000,0x3cf00000,0x3cf00000,0x1c000000,0xf00000,0x1f80000,0x1f00000,0x4480000,0x20000000,0x3c000000,0x1c000000,0x1c000000,0x20000000,0xf00000,0x1d80000,0x0,0x10000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1000,0x70a4,0x70a4,0x0,0x1000,0xa4,0x1000,0x1000,0xa4,0x1000,0x1000,0xa4,0x0,0x0,0x0,0x0,0x40,0xa4,0x40,0x0,0x58,0x0,0x0,0x100,0x0,0x100,0x0,0x100,0x0,0x10,0x0,0x4,0x0,0x0,0x0,0xa0,0x0,0x0,0x80,0x20,0x0,0x0,0x58,0x58,0x4,0x4,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x100,0x84,0xa4,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x84,0xa4,0x0,0x4,0x4,0x100,0x40,0x0,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x20,0x80,0x20,0x0,0x0,0x100,0x0,0x64,0x0,0x0,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x4,0x0,0x0,0x0,0x10,0x10,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x10,0x0,0x0,0x10,0x0,};
   }

  /** Constructor with InputStream. */
  public FormulaParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public FormulaParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new FormulaParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 135; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 135; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public FormulaParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new FormulaParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 135; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 135; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public FormulaParser(FormulaParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 135; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(FormulaParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 135; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[47];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 135; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 47; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
